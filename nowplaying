#!/usr/bin/env sh

# nowplaying.sh – A simple, POSIX-compliant shell script to print the
# "Now Playing" status of a local Plex Server to stdout.
#
# Copyright 2022 Justin Teague <arcadellama@posteo.net>
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the “Software”),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHE
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

# shellcheck disable=2034

export LC_ALL=C

########################################################################
## Global Read-only Variables
########################################################################
NP_PRGNAM="nowplaying-for-plex"
NP_VERSION="current"

## Default config locations
NP_CONFIG_FILENAME="${NP_PRGNAM}.conf"
NP_DEFAULT_CONFIGS="
${HOME}/.config/${NP_CONFIG_FILENAME}
${HOME}/.local/{$NP_PRGNAM}/${NP_CONFIG_FILENAME}
/usr/local/etc/${NP_CONFIG_FILENAME}
/etc/${NP_CONFIG_FILENAME}
"

## Global Log Variables
NP_LOG=""
NP_LOG_WARN=""
NP_LOG_ERROR=""

########################################################################
## Global Configurable Vars
########################################################################
NP_PLEX_TOKEN=""                   # This is the only "required" var
NP_COLOR_MODE=""                   # On, off or auto
NP_MAX_WIDTH=""                    # Maximum columns for stdout
NP_PLEX_HOST=""                    # Local-use only, not API
#NP_PLEX_PORT=""                    # Local-use only, not API

########################################################################
## Global Display Text and Color Variables
########################################################################
NP_DOT_LEADER="."                  # Delimiter used for dot leader
NP_HW_TRANSCODE_SYMBOL="•"         # Symbol to show hardware transcode
NP_SW_TRANSCODE_SYMBOL="◦"         # Symbol to show software transcode

## Text Color Definitions
TBLACK="\033[30m"
TRED="\033[31m"
TGREEN="\033[32m"
TYELLOW="\033[33m"
TBLUE="\033[34m"
TMAGENTA="\033[35m"
TCYAN="\033[36m"
TWHITE="\033[37m"
 
## Text Effect Definitions
TBOLD="\033[1m"
TITALIC="\033[3m"
TUNDERLINE="\033[4m"

## Reset text colors/effects
TRESET="\033[m"

## Color Output Options
NP_MOVIE_COLOR="$TBLUE"
NP_EPISODE_COLOR="$TCYAN"
NP_SONG_COLOR="$TMAGENTA"
NP_TRANSCODE_COLOR="$TGREEN"
NP_LOG_COLOR="$TGREEN"
NP_LOG_WARN_COLOR="$TYELLOW"
NP_LOG_ERROR_COLOR="$TRED"

########################################################################
## Print the logs on EXIT
########################################################################
trap '{
if [ -n "$verbose" ]; then
    [ -n "$NP_LOG" ] && printf "%s\n" "$NP_LOG" 
    [ -n "$NP_LOG_WARN" ] && printf "%s\n" "$NP_LOG_WARN" >&2
fi
[ -n "$NP_LOG_ERROR" ] && printf "%s\n" "$NP_LOG_ERROR" >&2
}' EXIT

########################################################################
## FUNCTIONS: String Manipulation 
########################################################################
list_add() {
    __var="$1"
    __val="$2"
    if [ -z "$__var" ]; then
        printf "%s" "$__val"
    else
        printf "%s\n%s" "$__var" "$__val"
    fi
}

arg_add() {
    __var="$1"
    __arg="$2"
    __val="$3"
    if [ -z "$__var" ]; then
        printf "%s %s\n" "$__arg" "$__val"
    else
        printf "%s%s %s\n" "$__var" "$__arg" "$__val"
    fi
}

file_exists() {
    __filename="$1"
    set -f
    # shellcheck disable=2086
    set -- $__filename
    for __file in "$@"; do
        if [ -r "$__file" ]; then
            printf "%s\n" "$__file"
            set +f
            return
        fi
    done
    set +f
}

get_item() {
    # Input variables
    __item="$1"
    __line="$2"

    set -f
    oldIFS=$IFS
    IFS='"'
    # shellcheck disable=2086
    set -- ${__line}
    while [ "$#" -gt 0 ]; do
        case "${1## }" in
            "$__item"=)
                printf "%s\n" "$2"
                shift 2 ;;
            *)
                shift ;;
        esac
    done
    IFS=$oldIFS
    set +f
}

truncate_string() {
    # Input variables
    __string="$1"
    __width="$2"
    __count="$(((${#__string} - __width) + 3))" # 3 additional for elipses

    while [ "$__count" -gt 0 ]; do
        __string="${__string%?}"
        __count="$((__count - 1))"
    done

    printf "%s..." "$__string"
}

print_delim() {
    __word="$1"
    __width="$2"
    __count=$((__width - __word))

    while [ "$__count" -gt 0 ]; do
        printf "%s" "$NP_DOT_LEADER"
        __count=$((__count - 1))
    done
}

fix_apostrophe() {
    __input="$1"
    __oldIFS=$IFS
    set -f
    IFS='&'
    # shellcheck disable=2086
    set -- ${__input}
    case "$2" in
        \#39\;*)
            IFS=$__oldIFS
            printf "%s'%s" "$1" "${2##\#39\;}"
            ;;
              *)
            printf "%s" "$1"
            ;;
    esac
    set +f
}

########################################################################
## FUNCTIONS: Colorized Output
########################################################################
color_check() {
    case "$color" in
        true|yes|on)
            return 0 ;;
       false|off|no)
            return 1 ;;
                  *)
            if [ -x "$(command -v tput)" ]; then
                if [ "$(tput colors)" ]; then
                    return 0
                fi
            fi
            return 1 ;;
    esac
}

set_color() {
    # Usage: set_color "string" "$color" "$effect" "$effect"
    __item="$1"
    __color="$2"
    __fx1="$3"
    __fx2="$4"

    if [ -n "$__fx2" ]; then
        printf "%b%b%b%s%b" "$__fx1" "$__fx2" "$__color" "$__item" "$TRESET"
        return
    elif [ -n "$__fx1" ]; then
        printf "%b%b%s%b" "$__fx1" "$__color" "$__item" "$TRESET"
        return
    elif [ -n "$__color" ]; then
        printf "%b%s%b" "$__color" "$__item" "$TRESET"
        return
    fi
    # Don't error-out if args aren't passed
    printf "%s" "$__item"
}

########################################################################
## FUNCTIONS: Logging
########################################################################
log() {
    __message="$1"  # Input variable
    __prefix="[$NP_PRGNAM]: "
    __output=""

    if color_check; then
        __prefix="$(set_color "$__prefix" "$NP_LOG_COLOR" "$TBOLD")"
    fi
    __output="${__prefix} ${__message}"
    NP_LOG="$(list_add "$NP_LOG" "$__output")"
}

log_warn() {
    __message="$1"  # Input variable
    __prefix="[$NP_PRGNAM] WARNING: "
    __output=""

    if color_check; then
        __prefix="$(set_color "$__prefix" "$NP_LOG_WARN_COLOR" "$TBOLD")"
    fi

    __output="${__prefix} ${__message}"
    NP_LOG_WARN="$(list_add "$NP_LOG_WARN" "$__output")"
}

log_error() {
    __message="$1"  # Input variable
    __prefix="[$NP_PRGNAM] ERROR: "
    __output=""

    if color_check; then
        __prefix="$(set_color "$__prefix" "$NP_LOG_ERROR_COLOR" "$TBOLD")"
    fi

    __output="${__prefix} ${__message}"
    NP_LOG_ERROR="$(list_add "$NP_LOG_ERROR" "$__output")"
}

########################################################################
## FUNCTIONS: Dependency and Configuration
########################################################################
check_uri() {
    case "$1" in
            *:*) return ;;
              *) return 1 ;;
    esac
}

parse_conf() {
    __conffile="$1"
    __return=""
    old_ifs=$IFS
    while IFS='=' read -r key val; do
        # Skip over lines containing comments.
        [ "${key##\#*}" ] || continue
        case "$key" in
            NP_PLEX_HOST) __return="$(arg_add "-p" "$val")" ;;
            NP_PLEX_TOKEN) __return="$(arg_add "-t" "$val")" ;;
            NP_MAX_WIDTH) __return="$(arg_add "-w" "$val")" ;;
            NP_COLOR_MODE) __return="$(arg_add "-c" "$val")" ;;
        esac
     done < "$__conffile"
     IFS=$old_ifs
     printf "%s\n" "$__return"
}

########################################################################
## FUNCTIONS: Download from the API
########################################################################
download_xml() {
    # Input variables passed from get_plexml()
    __host="$1"
    __path="$2"

    # Local variable
    __url="${__host}${__path}"

    case "$dl_agent" in
        *curl)
            "$dl_agent" -m "$timeout" -s "$__url"
             return "$?"
            ;;
         *wget)
            "$dl_agent" -T "$timeout" -qO - "$__url"
            return "$?" 
            ;;
         *fetch)
            "$dl_agent" -T "$timeout" -qO - "$__url"
            return "$?" 
            ;;
        esac
}

get_plexml() {
    ## Input variables passed from main()
    __type="$1" # either server or session
    __host="$2"

    ## Local variables
    __path=""
    __url=""

    case "$__type" in
        server)
            __path="$server_path"
            ;;
        session)
            __path="${server_path}${session_path}"
            ;;
    esac

    if [ -n "$plex_token" ]; then
        __path="${__path}${token_arg}${plex_token}"
    fi

    # Download the xml
    download_xml "$__host" "$__path"
}
########################################################################
## FUNCTIONS: Parse and Show the API data
########################################################################
print_nowplaying() {
    # Input variables from parse_session_xml
    __number="$1"
    __album="$(fix_apostrophe "$2")"
    __title="$(fix_apostrophe "$3")"
    __user="$4"
    __type="$5"
    __transcode="$6"

    # Local variables
    __track="$__title"
    __columns=""

    # Set column width
    if [ "$(command -v tput)" ]; then
	__columns="$("$(command -v tput)" cols)"
        if [ "$max_width" -ne 0 ] && [ "$__columns" -gt "$max_width" ]; then
	        __columns="$max_width"
	    fi
    else
        if [ "$max_width" -ne 0 ]; then
            __columns="$max_width"
        else
            __columns="80"
        fi
    fi

    __col1="$((${#__count} + 1))"
    __col3="$((${#__user} + 1))"
    __col2="$((__columns - (__col3 + __col1) - 4))"

    # Set global color
    if color_check; then
        __transcode="$(set_color "$__transcode" "$NP_TRANSCODE_COLOR" "$TBOLD")"
    fi

    case "$__type" in
        episode)
              # TV Episodes 
              __title="${__album}: ${__track}"

              # If it doesn't fit, spread over two lines
              if [ "${#__title}" -gt "$__col2" ]; then

                  if [ "${#__album}" -gt "$__col2" ]; then
                  __album="$(truncate_string "$__album" "$__col2")"
                  fi

                  if [ "${#__track}" -gt "$__col2" ]; then
                  __track="$(truncate_string "$__track" "$__col2")"
                  fi

                  __album="${__album}:"

                __output="$(printf "%${__col1}s %-${__col2}s%${__col3}s\n" \
                      "$__number." "$__album" "";  
                      printf "%${__col1}s %-${__col2}s%${__col3}s\n" \
                      "" "$__track $(print_delim ${#__track} ${__col2})" \
                      "$__user $__transcode")"
               else

                # Otherwise everything on one line
                __output="$(printf "%${__col1}s %-${__col2}s%${__col3}s\n" \
                  "$__number." \
                  "$__title $(print_delim ${#__title} ${__col2})" \
                  "$__user $__transcode")"

              fi
              if color_check; then
                __output="$(set_color "$__output" "$NP_EPISODE_COLOR" "$TBOLD")"
              fi
            ;;

          track)
              # Song tracks
              __title="${__album}: ${__track}"

              # If it doesn't fit, spread over two lines
              if [ "${#__title}" -gt "$__col2" ]; then

                  if [ "${#__album}" -gt "$__col2" ]; then
                  __album="$(truncate_string "$__album" "$__col2")"
                  fi

                  if [ "${#__track}" -gt "$__col2" ]; then
                  __track="$(truncate_string "$__track" "$__col2")"
                  fi

		          __album="${__album}:"

               # 2 lines
                __output="$(printf "%${__col1}s %-${__col2}s%${__col3}s\n" \
                      "$__number." "$__album" "";
                  printf "%${__col1}s %-${__col2}s%${__col3}s\n" \
                      "" "$__track $(print_delim ${#__track} ${__col2})" \
                      "$__user $__transcode")"
                else

                # All on one line
                __output="$(printf "%${__col1}s %-${__col2}s%${__col3}s\n" \
                      "$__number." \
                      "$__title $(print_delim ${#__title} ${__col2})" \
                      "$__user $__transcode")"

              fi
              if color_check; then
                __output="$(set_color "$__output" "$NP_SONG_COLOR" "$TBOLD")"
              fi
            ;;

          movie)
              # Movies

              if [ "${#__title}" -gt "$__col2" ]; then
                  __title="$(truncate_string "$__title" "$__col2")"
              fi
              __output="$(printf "%${__col1}s %-${__col2}s%${__col3}s\n" \
                  "$__number." \
                  "$__title $(print_delim ${#__title} ${__col2})" \
                  "$__user $__transcode")"
              if color_check; then
                __output="$(set_color "$__output" "$NP_MOVIE_COLOR" "$TBOLD")"
              fi
            ;;
    esac
    # Final print to screen
    printf "%s\n" "$__output"
}

parse_server_xml() {
    # Input variable from main
    __server_xml="$1"
    __host="$2" # not currently used,
    while IFS= read -r line; do
        case "$line" in
            *"401 Unauthorized"*)
                __errorMessage="Unauthorized access to $__host. "
                if [ -n "$plex_token" ]; then
                    log_error "$__errorMessage Invalid PLEX AUTH TOKEN."
                else
                    log_error "$__errorMessage $(printf "%s" \
                        "See the README on how to get a PLEX AUTH TOKEN")"
                fi
                exit 1
                ;;
            *friendlyName*)
                get_item "friendlyName" "$line"
                return
                ;;
        esac
    done << EOF
"$__server_xml"
EOF
}

parse_session_xml() {
    # Input variable from main
    __session_xml="$1"
    __host="$2"

    # Local variables
    __welcome_msg="Now Playing on $friendly_name: "
    __user="local" # Defaults to local for non-plex accounts
    __title=""
    __album=""
    __type=""
    __transcode=""
    __transcode_symbol=""
    __trans_type=""
    __count=0

    while IFS= read -r line; do
        case "$line" in
            ?Video*|?Track*)
                __type="$(get_item "type" "$line")"
                __album="$(get_item "grandparentTitle" "$line")"
                __title="$(get_item "title" "$line")"
                session_count="$((session_count+1))"
                ;;

            *User\ id*)
                __user="$(get_item "title" "$line")"
                ;;

            *TranscodeSession*)
                __trans_type=$(get_item "transcodeHwFullPipeline" "$line")
                if [ "$__trans_type" -eq 1 ]; then
                    __transcode_symbol="$NP_HW_TRANSCODE_SYMBOL"
                else
                    __transcode_symbol="$NP_SW_TRANSCODE_SYMBOL"
                fi
                __transcode="$__transcode_symbol"
                ;;

            */Video*|*/Track*)
                # Check if this is the first item
                if [ "$__count" -eq 0 ]; then
                        printf "\n"

                    if color_check; then
                        __welcome_msg="$(set_color \
                            "$__welcome_msg" "$TWHITE" "$TITALIC" "$TBOLD")"
                    fi
                        printf "%s\n" "$__welcome_msg"
                    __count="$((__count+1))"
                fi

                ###### Print to screen! #####
                print_nowplaying "$__count" "$__album" \
                    "$__title" "$__user" "$__type" "$__transcode"
                __count="$((__count+1))"
                ;;
            */MediaContainer*)
                # Check if end of xml file
                if [ "$session_count" -gt 0 ]; then
                    printf "\n"
                fi
                ;;
        esac
    done << EOF
"$__session_xml"
EOF

     log "Nothing playing on $friendly_name ($__host)"
}

print_help() {
cat <<EOF

$NP_PRGNAM, NP_VERSION $NP_VERSION
A command-line script to print the "Now Playing" status of
a Plex server to stdout.

Example: 'nowplaying -p 192.168.1.1:32400 -w 80 -t <PLEX_AUTH_TOKEN>'

           --help, -h   This screen

  --config, -c <file>   Configuration file. Overrides command args.

      --plex, -p <ip>    Full URI with ip:port of Plex Server
                         separated by commas, no spaces.
                         Default=127.0.0.1:32400

    --token, -t <path>   Plex Auth Token, optional point to file.

     --timeout <value>   Time to wait for connection, default=1

      --color <on|off>   Color setting. Default is to attempt to discover
                         your terminal settings and set accordingly.

   --width, -w <number>  Maximum number of columns width.
                         Default=0, "infinite"

          --version, -v  Show NP_VERSION

          --curl <path>  Force curl as downloader.
                         (Path is optional.)

          --wget <path>  Force wget as downloader.
                         (Path is optional.)

         --fetch <path>  Force fetch as downloader.
                         (Path is optional.)

         --verbose, -V   Print every error message.

                --file   Point to a XML file for debugging

Configuration:
    If no --config,-c is given, nowplaying will look in:
            ~/.config/$NP_PRGNAM.conf
            ~/.local/$NP_PRGNAM/$NP_PRGNAM.conf
            /usr/local/etc/$NP_PRGNAM.conf
            /etc/$NP_PRGNAM.conf

EOF
}

main() {
    command_args="$1"
    
    ## Optional command-line variables
    plex_host="127.0.0.1:32400"     # Plex server IP(s), separated by comma
    #plex_port="32400"              # deprecated
    plex_token=""                   # Auth token for Plex
    color=""                        # Toggle color output--default is "auto"
    config_file=""                  # Location for configuration file
    max_width="0"                   # Set the maximum width of print; 0=inf
    verbose=""                      # Chatty NP_VERSION
    dl_agent=""                     # Either curl, wget, fetch or nc
    #skip_checks=""                 # Deprecated
    plex_file=""                    # Optional XML for testing
    timeout=1                       # Timeout for downloading xml file
    
    ## Global accessible variables
    friendly_name="Plex"            # Default server name
    server_path="/"                 # Base path for plex API
    session_path="status/sessions"  # Path for sessions API
    token_arg="?X-Plex-Token="      # Plex token arg
    session_count=0                 # Toggle for active session

    ## Local vars for main
    __conffile=""                   # Location of config file

    # Check for conf file first so command args may override
    __conffile="$(file_exists "$NP_DEFAULT_CONFIGS")"
    if [ -r "$__conffile" ]; then
        __conf_args="$(parse_conf "$__conffile")"
        command_args="${__conf_args} ${command_args}"
    fi

    set -f
    # shellcheck disable=2086
    set -- $command_args
    while [ "$#" -gt 0 ]; do
        case "$1" in 
       --config|-c)
                if [ ! -r "$2" ]; then
                    log_error "$2 config file not found."
                    exit 1
                fi
                config_file="$2"
                shift 2 ;;
         --plex|-p)
                plex_host="$2"
                shift 2 ;;
            --port)
                log_warn "--port is deprecated; use full uri for host instead"
                plex_port="$2"
                shift 2 ;;
        --token|-t)
                plex_token="$2"
                shift 2 ;;
         --timeout)
                timeout="$2"
                shift 2 ;;
        --width|-w)
                max_width="$2"
                shift 2 ;;
           --color)
                case "$2" in
                    on|off|auto|true|false|yes|no)
                        color="$2" 
                        shift 2 ;;
                    *)
                        color="on"
                        shift 1 ;;
                esac ;;
            --file)
                plex_file="$2"
                shift 2 ;;
        --force|-f)
		        log_warn "--force is deprecated."
                skip_checks=1
                shift 1 ;;
            --curl)
                case "$2" in
                    *curl)
                        if [ -x "$2" ]; then
                            dl_agent="$2"
                            shift 2 
                        else
                            log_error "Cannot find $2"
                            exit 1
                        fi
                        ;;
                        *)
                        if ! dl_agent="$(command -v curl)"; then
                            log_error "Cannot find curl"
                        fi
                        shift 1 
                esac
                skip_checks=1 ;;

            --wget)
                case "$2" in
                    *wget)
                        if [ -x "$2" ]; then
                            dl_agent="$2"
                            shift 2 
                        else
                            log_error "Cannot find $2"
                            exit 1
                        fi ;;
                        *)
                        if ! dl_agent="$(command -v wget)"; then
                            log_error "Cannot find wget"
                            exit 1
                        fi
                        shift 1 ;;
                esac
                skip_checks=1 ;;
           --fetch)
                case "$2" in
                    *fetch)
                        if [ -x "$2" ]; then
                            dl_agent="$2"
                            shift 2 
                        else
                            log_error "Cannot find $2"
                            exit 1
                        fi
                        ;;
                        *)
                        if ! dl_agent="$(command -v fetch)"; then
                            log_error "Cannot find fetch"
                            exit 1
                        fi
                        shift 1 ;;
                esac
                skip_checks=1 ;;
--verbose|-V|--debug)
                verbose="1"
                shift 1 ;;
         --help|-h)
                print_help
                exit 0 ;;
      --version|-v)
                printf "%s: %s\n" "$NP_PRGNAM" "$NP_VERSION"
                exit 0 ;;
                 *)
                log_error "$(printf "%s %s%s" "$1" \
                    "is not a valid expression. "\
                    "Try nowplaying --help for help.")"
                exit 1 ;;
        esac
    done
    set +f

    # If config file is given it overrides command line args
    if [ -n "$config_file" ]; then
        old_ifs=$IFS
        while IFS='=' read -r key val; do
            # Skip over lines containing comments.
            [ "${key##\#*}" ] || continue
              case "$key" in
                  NP_PLEX_HOST) plex_host="$val" ;;
                  NP_PLEX_PORT) plex_port="$val" ;;
                 NP_PLEX_TOKEN) plex_token="$val" ;;
                  NP_MAX_WIDTH) max_width="$val" ;;
                 NP_COLOR_MODE) color="$val" ;;
              esac
          done < "$config_file"
        IFS=$old_ifs
    fi

    # Check for and set download agent
    if [ -z "$dl_agent" ]; then
        for __agent in curl wget fetch nc; do
            dl_agent="$(command -v "$__agent")" && break
        done
        [ -x "$dl_agent" ] || log_error "curl, wget, fetch, or nc not found."
    fi

    # Debug mode check, simply cat the given xml file for testing
    if [ -n "$plex_file" ]; then
        parse_session_xml "$(cat "$plex_file")"
        return
    fi
    
    __servers_found=0
    set -f
    # shellcheck disable=2086
    set -- $plex_host
    for __server in "$@"; do
        old_ifs=$IFS
        IFS=,
        set -- $__server
        for __host in "$@"; do
            if ! check_uri "$__host"; then
                __retval="$?"
                log_warn "Missing port in uri, e.g.,'$__host:32400'" 
                continue
            fi
            __server_xml="$(download_xml "${__host}/")"
            __session_xml="$(download_xml "$__host/status/sessions")"

            if friendly_name="$(parse_server_xml "$__server_xml")"; then
                parse_session_xml "$__session_xml" "$__host"
                __servers_found=$((__servers_found+1))
                break
            else
                __retval="$?"
            fi
        done
        IFS=$old_ifs
    done

    if [ "$__servers_found" -eq 0 ]; then
        log_error "No servers found at $plex_host (Error code: $__retval)"
        return "$__retval"
    fi
}
main "$*"
